{"pages":[{"title":"关于我","text":"我是郑逸潇，来自浙江台州，现就读于魔都华东师范大学数据科学与工程学院，热爱计算机、数学、物理。 欢迎大家来看我的博客，也欢迎大家与我交流分享相关知识。 联系方式：QQ：1102100299github账号：zyx-406","link":"/about/index.html"},{"title":"与她","text":"","link":"/abouther/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"AddList.c","text":"1234567891011121314151617181920212223242526272829303132#include \"LinkedList.h\"ListNode *addlist1() //整个数据读取，建立和放入链表都由此函数处理{ int in=0; //in来临时存放读取的数据 ListNode *head=NULL; //头指针 while(in!=-1) { scanf(\"%d\",&amp;in); //读取数据并存放于in if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表 { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL ListNode *tail=head; //定义一个tail寻找此链表的尾端 if(tail) //此处判断tail是否为起始时刻等于NULL的head，若不是则进行下一步寻找 { while(tail-&gt;next) //当tail的next有指向(不是NULL，因为NULL代表0)，则使tail指向下一个节点 { tail=tail-&gt;next; //tail指向下一个节点 } tail-&gt;next=p; //当tail为NULL了让tail指向p，就将p节点从尾端连入链表了 } else { head=p; //此处当head指向NULL时，p为第一个节点 } } } return head; //返回head(传出去的是第一个节点的地址，这个head的地址是在函数调用栈中的，比方在main函数中head=addlist1()，此main中的head与函数中的head的地址不同，但是它们指向的地址是相同的，也就是链表的第一个节点，而链表的节点是由malloc函数实现，当我们没有free它时，它是不会失效的)} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112void addlist2(ListNode *head,int in) //数据在外面读取，此函数负责建立链表并放入，但存在bug，因为此函数的头地址head与传入的地址不是同一个地址，无法在原地方增加链表 所以这是一个错误的函数！！！{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL ListNode *tail=head; //定义一个tail寻找此链表的尾端 if(tail) //此处判断tail是否为起始时刻等于NULL的head，若不是则进行下一步寻找 { while(tail-&gt;next) //当tail的next有指向(不是NULL，因为NULL代表0)，则使tail指向下一个节点 { tail=tail-&gt;next; //tail指向下一个节点 } tail-&gt;next=p; //当tail为NULL了让tail指向p，就将p节点从尾端连入链表了 } else { head=p; //此处当head指向NULL时，p为第一个节点 } }}ListNode *addlist3(ListNode *head,int in) //此函数解决了addlist2的问题，需要返回此函数中head的值，但其实无需传入head的地址，自己定义一个传出也行{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL ListNode *tail=head; //定义一个tail寻找此链表的尾端 if(tail) //此处判断tail是否为起始时刻等于NULL的head，若不是则进行下一步寻找 { while(tail-&gt;next) //当tail的next有指向(不是NULL，因为NULL代表0)，则使tail指向下一个节点 { tail=tail-&gt;next; //tail指向下一个节点 } tail-&gt;next=p; //当tail为NULL了让tail指向p，就将p节点从尾端连入链表了 } else { head=p; //此处当head指向NULL时，p为第一个节点 } } return head; //返回head(传出去的是第一个节点的地址，这个head的地址是在函数调用栈中的，比方在main函数中head=addlist1()，此main中的head与函数中的head的地址不同，但是它们指向的地址是相同的，也就是链表的第一个节点，而链表的节点是由malloc函数实现，当我们没有free它时，它是不会失效的)}void addlist4(ListNode **pHead,int in) //此函数用另一种方法(二级指针)解决了addlist2的问题，且无需返回值{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL ListNode *tail=*pHead; //定义一个tail寻找此链表的尾端 if(tail) //此处判断tail是否为起始时刻等于NULL的head，若不是则进行下一步寻找 { while(tail-&gt;next) //当tail的next有指向(不是NULL，因为NULL代表0)，则使tail指向下一个节点 { tail=tail-&gt;next; //tail指向下一个节点 } tail-&gt;next=p; //当tail为NULL了让tail指向p，就将p节点从尾端连入链表了 } else { *pHead=p; //此处当head指向NULL时，p为第一个节点 } }}//typedef struct _List{ //定义一个结构体包含head和tail可以简化tail的运算// ListNode *head;// ListNode *tail;//}List;void addlist5(List *pList,int in) //加入List结构体定义也可以解决addlist2问题，且加入的List中的tail可以简化tail的运算{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL if(pList-&gt;tail) //此处判断pList-&gt;tail是否为NULL { pList-&gt;tail-&gt;next=p; //使得pList-&gt;tail-&gt;next指向p，就将p节点从尾端连入链表了 pList-&gt;tail=p; //pList-&gt;tail指向p节点 } else { pList-&gt;head=p; //此处当pList-&gt;tail指向NULL时，p为第一个节点 pList-&gt;tail=p; //此处当pList-&gt;tail指向NULL时，p为第一个节点，所以head和tail都是这个节点 } }}void addhead(List *pList,int in) //头部插入新数据{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=pList-&gt;head; //让这个节点的next为head if(pList-&gt;head) //此处判断pList-&gt;tail是否为NULL { pList-&gt;head=p; //使得pList-&gt;head指向p，就将p节点从首端连入链表了 } else { pList-&gt;head=p; //此处当pList-&gt;head指向NULL时，p为第一个节点 pList-&gt;tail=p; //此处当pList-&gt;head指向NULL时，p为第一个节点，所以head和tail都是这个节点 } }}","link":"/2020/07/02/AddList-c/"},{"title":"FreeList.c","text":"1234567891011#include \"LinkedList.h\"void freelist(List *pList) //清除整个链表{ ListNode *p=pList-&gt;head,*q=p; for(;p;p=q) //以往的p=p-&gt;next由p=q代替，q在函数中-&gt;next { q=p-&gt;next; free(p); }}","link":"/2020/07/02/FreeList-c/"},{"title":"DeleteNode.c","text":"第一个代码是按照MOOC代码的改编，所以最后的逻辑处理会有些乱，稍后更新新的代码。 12345678910111213141516171819202122232425262728293031323334#include \"LinkedList.h\" void delete(List *pList,int in) //删除包含in数据的所有节点 { ListNode *p; ListNode *q=NULL; ListNode temp; for(p=pList-&gt;head;p;p=p-&gt;next) //标准遍历 { if(p-&gt;data==in) { if(q) //当q不为NULL时前一个q的next指向p的next即可 { q-&gt;next=p-&gt;next; } else //若q是NULL，也就是说第一个就是我们要删除的节点，让head指向下一个就好 { pList-&gt;head=p-&gt;next; } free(p); //释放malloc来的p if(q) p=q,q=p; //这后面也是重点，因为上面的p已经free掉了，所以p需要重新赋值，才可以删除所有包含in数据的节点，但是由于这个程序这样写逻辑太复杂了，后面我会更新一下简单逻辑的算法。 else { temp.next=pList-&gt;head; p=&amp;temp; } } else { q=p; } } } 第二个代码它来了！ 1234567891011121314151617181920212223242526272829303132#include \"LinkedList.h\"void delete(List *pList,int in){ ListNode *p; ListNode *q=NULL; while(pList-&gt;head) //这里将head部分单独拎出来做文章，避免后面由于考虑head导致逻辑混乱。 { if(pList-&gt;head-&gt;data!=in) break; //如果head不是所要删除的数据直接break开始下个循环。 else //如果是要删除的，删除它并重新赋值head为下一个，free原来的head { q=pList-&gt;head; pList-&gt;head=pList-&gt;head-&gt;next; free(q); } } p=q=pList-&gt;head; //这里我们可以确定head要么没有，为NULL，要么head的数据不是我们需要删除的 while(p) { if(p-&gt;data==in) //如果p的数据是要删除的，进行以下步骤 { q-&gt;next=p-&gt;next; free(p); p=q-&gt;next; //这步就是让整个循环得以进行下去的点，要注意p只需要是q的next就行，因为q的next并没有检查过，且q不变，因而不能和下面的代码合并 } else //如果不是就让q是这个，p往下走就行了 { q=p; p=p-&gt;next; } }}","link":"/2020/07/02/DeleteNode-c/"},{"title":"TraverseList.c","text":"123456789101112131415161718192021222324252627#include \"LinkedList.h\"void print(List *pList) //此函数将链表所有数据输出{ ListNode *p=pList-&gt;head; for(p=pList-&gt;head;p;p=p-&gt;next) //链表遍历常规操作，让p从head开始 当p不为NULL进入循环，之后p指向下一个节点 { printf(\"%d \",p-&gt;data); //输出数据 } printf(\"\\n\");}ListNode *search(List *pList,int in) //此函数搜索链表中有无 in 的数据，并将第一个搜索到的地址返回，若未找到返回NULL{ int flag=0; //用来表示是否找到 ListNode *p=pList-&gt;head; for(;p;p=p-&gt;next) { if(p-&gt;data==in) { flag=1; break; } } if(flag) return p; //找到返回p，未找到返回NULL else return NULL;}","link":"/2020/07/02/TraverseList-c/"},{"title":"InsertNode.c","text":"这部分暂时还没来得及注释，而且实现的可能有点不好 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include \"LinkedList.h\"void insertnode(List *pList,int in) //我这里想实现的是顺序插入，即将给出的数据按从小到大排列{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL int flag=1; ListNode *i=pList-&gt;head,*j=NULL; if(pList-&gt;head) { for(i=pList-&gt;head;i;j=i,i=i-&gt;next) //链表遍历常规操作，让p从head开始 当p不为NULL进入循环，之后p指向下一个节点 { if(!j&amp;&amp;i-&gt;data&gt;in) { p-&gt;next=pList-&gt;head; pList-&gt;head=p; flag=0; break; } else if(i-&gt;data&gt;in&amp;&amp;j) { j-&gt;next=p; p-&gt;next=i; flag=0; break; } else; } if(flag) { pList-&gt;tail-&gt;next = p; pList-&gt;tail = p; } } else { pList-&gt;head=p; //此处当pList-&gt;tail指向NULL时，p为第一个节点 pList-&gt;tail=p; //此处当pList-&gt;tail指向NULL时，p为第一个节点，所以head和tail都是这个节点 } }}","link":"/2020/07/02/InsertNode-c/"},{"title":"LinkList.h","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#ifndef LINKEDLIST_LINKEDLIST_H#define LINKEDLIST_LINKEDLIST_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;typedef struct ListNode{ //定义单向链表节点结构体 int data; //链表数据 struct ListNode *next; //指向下一个链表的指针}ListNode; //结构名(可以与上面相同)//*最重要！链表的增加函数，这里以-1为结束标志(之后操作链表尾增加函数都用第五个) 前五个在尾端插入结点，最后一个addhead在头部插入ListNode *addlist1(); //整个数据读取，建立和放入链表都由此函数处理void addlist2(ListNode *head,int in); //数据在外面读取，此函数负责建立链表并放入，但存在bug，因为此函数的头地址head与传入的地址不是同一个地址，无法在原地方增加链表ListNode *addlist3(ListNode *head,int in); //此函数解决了addlist2的问题，需要返回此函数中head的值void addlist4(ListNode **pHead,int in); //此函数用另一种方法(二级指针)解决了addlist2的问题，且无需返回值typedef struct List{ //定义一个结构体包含head和tail可以简化tail的运算 ListNode *head; ListNode *tail;}List;void addlist5(List *pList,int in); //加入List结构体定义也可以解决addlist2问题，且加入的List中的tail可以简化tail的运算void addhead(List *pList,int in); //头部插入新数据//链表节点插入，即在链表中间特定地址插入一个结点void insertnode(List *pList,int in); //我这里想实现的是顺序插入，即将给出的数据按从小到大排列//链表的搜索(遍历)void print(List *pList); //此函数将链表所有数据输出ListNode *search(List *pList,int in); //此函数搜索链表中有无 in 的数据，并将第一个搜索到的地址返回//链表的删除void delete(List *pList,int in); //删除包含in数据的节点//链表的清除 freevoid freelist(List *pList); //清除整个链表#endif //LINKEDLIST_LINKEDLIST_H","link":"/2020/07/02/LinkList-h/"},{"title":"天降大任、苦难出头、花繁九州","text":"“不要成为996 007的社畜，也不要成为高智商高情商无使命的精致利己者” ——华东师范大学校长钱旭红 华东师范大学2020届毕业典礼举行","link":"/2020/06/25/%E5%A4%A9%E9%99%8D%E5%A4%A7%E4%BB%BB%E3%80%81%E8%8B%A6%E9%9A%BE%E5%87%BA%E5%A4%B4%E3%80%81%E8%8A%B1%E7%B9%81%E4%B9%9D%E5%B7%9E/"},{"title":"分类统计字符个数","text":"题目如下： 起初本题的输入令我十分难以理解，没有一个确定的终止命令，后来想到ctrl+Z为终止指令，初步尝试使用getchar函数结果也总是不对。经过研究发现，oj平台的终止方式和我们stdin的不太一样，如果加上换行和ctrl+Z就多了两个字符，我们需要把这两个字符去掉，同时也要注意在开始的时候要是直接输入ctrl+Z换行符的计数是会变成-1的；初步改了一下将这个情况给排除掉就可以过验了。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 100void input(char s[]);void StringCount(char s[]);int main(){ char s[N]={0}; input(s); StringCount(s); return 0;}//读取字符串并放入数组s中void input(char s[]){ int i=0; while((s[i]=getchar())!=EOF) i++;}//处理并输出统计字符的个数void StringCount(char s[]){ int letter=0,kghc=0,digit=0,others=0; while(*s) { if((*s&gt;='a'&amp;&amp;*s&lt;='z')||(*s&gt;='A'&amp;&amp;*s&lt;='Z')) letter++; else if(*s==' '||*s=='\\n') kghc++; else if(*s&gt;='0'&amp;&amp;*s&lt;='9') digit++; else others++; s++; } if(s[1]=='\\0') kghc++; //这一步就是把直接ctrl+Z的情况给排除 printf(\"%d %d %d %d\",letter,--kghc,digit,--others);} 经过与老师同学的交流得知，这类题最好的做法是将字符串逐行进行处理，换行的count++即可 xmx更改的代码如下：123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 100int letter=0,kghc=0,digit=0,others=0;void StringCount(char s[]);int main(){ char s[N]={0}; while(gets(s)!=NULL) { StringCount(s); kghc++; } kghc--; //将最后一个换行给去掉。（ps：但是很奇怪的是用这个逐行读入的居然是不用考虑直接ctrl+Z的情况，尽管我们的终端显示是错误的，但是能过验，这可能与oj平台的测试方式有关） printf(\"%d %d %d %d\",letter,kghc,digit,others); return 0;}void StringCount(char s[]){ while(*s) { if((*s&gt;='a'&amp;&amp;*s&lt;='z')||(*s&gt;='A'&amp;&amp;*s&lt;='Z')) letter++; else if(*s==' '||*s=='\\n') kghc++; else if(*s&gt;='0'&amp;&amp;*s&lt;='9') digit++; else others++; s++; }} 令人更难解的操作来了： 这道题又说明了oj与我们自己的shell的不同 我的过验代码为：12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 100void StringCount(char *s);int main(){ char s[N]={0},t[N]={0}; int i=0; while((s[i]=getchar())!=EOF) i++; s[i]='\\0'; StringCount(s); return 0;}void StringCount(char *s){ int LETTER=0,letter=0,blank=0,digit=0,others=0; for(int i=0;s[i];i++) { if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') LETTER++; else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') letter++; else if(s[i]==' ') blank++; else if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') digit++; else others++; } printf(\"%d %d %d %d %d\",LETTER,letter,blank,digit,others);} 但是在我个人终端的输出是错误的，样例都是错的，输出2 2 1 3 5，不太懂oj和我们的终端的判别到底是怎么不一样的。 至于EOF和NULL链接如下：EOF NULL while(gets(s)!=NULL)指的就是gets()返回过来的是个空指针的话就停下了","link":"/2020/06/28/%E5%88%86%E7%B1%BB%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0/"},{"title":"第一篇博客","text":"这是我的第一篇博客搭建基础博客为了比较完整搭建它，耗费了三天时间，看了许多博主的安装教程，其中关于搭建hexo+github page我觉得最全的是b站 0饭盒君 的教程 链接如下： 如何使用hexo+github搭建个人博客（直播录制） 更改主题在知乎逛了一下看见这款icarus，就下定决心是它了！界面简洁，功能又一样不少。 链接如下： icarus主题 按照说明文档来进行更改（英文一定要好，不然只能靠翻译或者搜别人的更改后文档），其中也踩了几次坑，比如遇到： 123456# Alipay donate button configurations- type: alipay # Alipay qrcode image URL qrcode: ''# Wechat donate button configurations 要想把这一部分全部注释掉，就要把# Alipay donate button configurations下面的那行的 - 一整行删掉或者同样注释掉，这是很容易忽略的一行代码。 头像、图表都还没改，等logo设计出来了再改吧","link":"/2020/06/24/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"单向链表概况","text":"本体系总体参照浙江大学MOOC翁老师的视频，链接如下： C语言程序设计CAPC语言程序设计进阶 单向链表介绍 单向链表（单链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始；链表是使用指针进行构造的列表；又称为结点列表，因为链表是由一个个结点组装起来的；其中每个结点都有指针成员变量指向列表中的下一个结点； 链表是由结点构成，head指针指向第一个成为表头结点，而终止于最后一个指向NULL的指针。 链表相对于数组比较优点： 链表可以有效控制内存使用大小，不会像数组一样出现内存取多了或者少了(数组的大小只能一开始就确定，可变数组也需要不断建立新的再复制，比较麻烦)； 链表在中间插入或删除数据比较方便，只需要进行结点的变化，数组(比较大的数组)新建或删除需要进行大规模移动； 缺点： 单向链表的结点的访问只能顺序访问，当数据规模大了，访问速度比数组慢； 链表占用内存空间较大，其包含数据和指针两部分； 链表的学习和使用 下面是代码实践操作(建议与MOOC共同食用) 单向链表结构体的定义：数据+此结构体类型的指针(这里包括各类函数的定义) 最重要！ 单向链表的建立，包括尾部插入新数据和头部插入新数据 单向链表的插入数据(中间)，在链表中插入新的数据 单向链表的遍历(我这里包括打印链表和搜索特定数据) 单向链表的删除结点 单向链表的清除(使用完后要清除链表)","link":"/2020/07/02/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"},{"title":"CSAPP_bomblab_bomb_6","text":"这是我们这学期计算机系统课（CSAPP）的一个实验，由CMU引进，我所做的bomb是bomb_6。二进制炸弹是一个作为目标代码文件提供给学生们的程序。运行时，它提示用户输入6个不同的字符串。如果其中的任何一个不正确，炸弹就会“爆炸”，打印出一条错误信息。学生们必须通过对程序反汇编（objdump）和查看理解汇编代码来确定应该输入哪6个字符串，从而解除他们各自炸弹的雷管。 前期准备：使用GDB：这是我们班同学的关于使用GDB的文章GDB简易使用指南 objdump：（可选）大家可以去网上查询objdump的使用方法，这个实验只用到了以下的方法：objdump -d bomb_6或者用objdump -d bomb_6 &gt; bomb_6.d将反汇编代码保存在bomb_6.d的文件中（会在同级文件夹下生成）。 这里就是objdump反汇编出来的代码 main123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687080489db &lt;main&gt;: 80489db: 8d 4c 24 04 lea 0x4(%esp),%ecx 80489df: 83 e4 f0 and $0xfffffff0,%esp 80489e2: ff 71 fc pushl -0x4(%ecx) 80489e5: 55 push %ebp 80489e6: 89 e5 mov %esp,%ebp 80489e8: 53 push %ebx 80489e9: 51 push %ecx 80489ea: 8b 01 mov (%ecx),%eax 80489ec: 8b 59 04 mov 0x4(%ecx),%ebx 80489ef: 83 f8 01 cmp $0x1,%eax 80489f2: 75 0c jne 8048a00 &lt;main+0x25&gt; 80489f4: a1 c0 c3 04 08 mov 0x804c3c0,%eax 80489f9: a3 d0 c3 04 08 mov %eax,0x804c3d0 80489fe: eb 5b jmp 8048a5b &lt;main+0x80&gt; 8048a00: 83 f8 02 cmp $0x2,%eax 8048a03: 75 39 jne 8048a3e &lt;main+0x63&gt; 8048a05: 83 ec 08 sub $0x8,%esp 8048a08: 68 a8 9e 04 08 push $0x8049ea8 8048a0d: ff 73 04 pushl 0x4(%ebx) 8048a10: e8 0b fe ff ff call 8048820 &lt;fopen@plt&gt; 8048a15: a3 d0 c3 04 08 mov %eax,0x804c3d0 8048a1a: 83 c4 10 add $0x10,%esp 8048a1d: 85 c0 test %eax,%eax 8048a1f: 75 3a jne 8048a5b &lt;main+0x80&gt; 8048a21: ff 73 04 pushl 0x4(%ebx) 8048a24: ff 33 pushl (%ebx) 8048a26: 68 aa 9e 04 08 push $0x8049eaa 8048a2b: 6a 01 push $0x1 8048a2d: e8 0e fe ff ff call 8048840 &lt;__printf_chk@plt&gt; 8048a32: c7 04 24 08 00 00 00 movl $0x8,(%esp) 8048a39: e8 a2 fd ff ff call 80487e0 &lt;exit@plt&gt; 8048a3e: 83 ec 04 sub $0x4,%esp 8048a41: ff 33 pushl (%ebx) 8048a43: 68 c7 9e 04 08 push $0x8049ec7 8048a48: 6a 01 push $0x1 8048a4a: e8 f1 fd ff ff call 8048840 &lt;__printf_chk@plt&gt; 8048a4f: c7 04 24 08 00 00 00 movl $0x8,(%esp) 8048a56: e8 85 fd ff ff call 80487e0 &lt;exit@plt&gt; 8048a5b: e8 d1 05 00 00 call 8049031 &lt;initialize_bomb&gt; 8048a60: 83 ec 0c sub $0xc,%esp 8048a63: 68 2c 9f 04 08 push $0x8049f2c 8048a68: e8 53 fd ff ff call 80487c0 &lt;puts@plt&gt; 8048a6d: c7 04 24 68 9f 04 08 movl $0x8049f68,(%esp) 8048a74: e8 47 fd ff ff call 80487c0 &lt;puts@plt&gt; 8048a79: e8 a5 06 00 00 call 8049123 &lt;read_line&gt; 8048a7e: 89 04 24 mov %eax,(%esp) 8048a81: e8 ad 00 00 00 call 8048b33 &lt;phase_1&gt; 8048a86: e8 91 07 00 00 call 804921c &lt;phase_defused&gt; 8048a8b: c7 04 24 94 9f 04 08 movl $0x8049f94,(%esp) 8048a92: e8 29 fd ff ff call 80487c0 &lt;puts@plt&gt; 8048a97: e8 87 06 00 00 call 8049123 &lt;read_line&gt; 8048a9c: 89 04 24 mov %eax,(%esp) 8048a9f: e8 b0 00 00 00 call 8048b54 &lt;phase_2&gt; 8048aa4: e8 73 07 00 00 call 804921c &lt;phase_defused&gt; 8048aa9: c7 04 24 e1 9e 04 08 movl $0x8049ee1,(%esp) 8048ab0: e8 0b fd ff ff call 80487c0 &lt;puts@plt&gt; 8048ab5: e8 69 06 00 00 call 8049123 &lt;read_line&gt; 8048aba: 89 04 24 mov %eax,(%esp) 8048abd: e8 f5 00 00 00 call 8048bb7 &lt;phase_3&gt; 8048ac2: e8 55 07 00 00 call 804921c &lt;phase_defused&gt; 8048ac7: c7 04 24 ff 9e 04 08 movl $0x8049eff,(%esp) 8048ace: e8 ed fc ff ff call 80487c0 &lt;puts@plt&gt; 8048ad3: e8 4b 06 00 00 call 8049123 &lt;read_line&gt; 8048ad8: 89 04 24 mov %eax,(%esp) 8048adb: e8 ed 01 00 00 call 8048ccd &lt;phase_4&gt; 8048ae0: e8 37 07 00 00 call 804921c &lt;phase_defused&gt; 8048ae5: c7 04 24 c0 9f 04 08 movl $0x8049fc0,(%esp) 8048aec: e8 cf fc ff ff call 80487c0 &lt;puts@plt&gt; 8048af1: e8 2d 06 00 00 call 8049123 &lt;read_line&gt; 8048af6: 89 04 24 mov %eax,(%esp) 8048af9: e8 41 02 00 00 call 8048d3f &lt;phase_5&gt; 8048afe: e8 19 07 00 00 call 804921c &lt;phase_defused&gt; 8048b03: c7 04 24 0e 9f 04 08 movl $0x8049f0e,(%esp) 8048b0a: e8 b1 fc ff ff call 80487c0 &lt;puts@plt&gt; 8048b0f: e8 0f 06 00 00 call 8049123 &lt;read_line&gt; 8048b14: 89 04 24 mov %eax,(%esp) 8048b17: e8 6b 02 00 00 call 8048d87 &lt;phase_6&gt; 8048b1c: e8 fb 06 00 00 call 804921c &lt;phase_defused&gt; 8048b21: 83 c4 10 add $0x10,%esp 8048b24: b8 00 00 00 00 mov $0x0,%eax 8048b29: 8d 65 f8 lea -0x8(%ebp),%esp 8048b2c: 59 pop %ecx 8048b2d: 5b pop %ebx 8048b2e: 5d pop %ebp 8048b2f: 8d 61 fc lea -0x4(%ecx),%esp 8048b32: c3 ret 第一关123456789101108048b33 &lt;phase_1&gt;: 8048b33: 83 ec 14 sub $0x14,%esp 8048b36: 68 e4 9f 04 08 push $0x8049fe4 8048b3b: ff 74 24 1c pushl 0x1c(%esp) 8048b3f: e8 88 04 00 00 call 8048fcc &lt;strings_not_equal&gt; 8048b44: 83 c4 10 add $0x10,%esp 8048b47: 85 c0 test %eax,%eax 8048b49: 74 05 je 8048b50 &lt;phase_1+0x1d&gt; 8048b4b: e8 73 05 00 00 call 80490c3 &lt;explode_bomb&gt; 8048b50: 83 c4 0c add $0xc,%esp 8048b53: c3 ret 这是最简单的一题，关键在于strings_not_equal函数和它的前两行 1238048b36: 68 e4 9f 04 08 push $0x8049fe4 //将这个地址 里的东西压入栈8048b3b: ff 74 24 1c pushl 0x1c(%esp) //将输入的字符串压入栈8048b3f: e8 88 04 00 00 call 8048fcc &lt;strings_not_equal&gt; //这个函数比较两个字符串是否相同（从函数名就可以看出） 因此我们需要把0x8049fe4地址里的东西找出来 这里用到了x打印出这个内存地址里的内容，以下是x的使用方法 12345678910111213(gdb) help xExamine memory: x/FMT ADDRESS.ADDRESS is an expression for the memory address to examine.FMT is a repeat count followed by a format letter and a size letter.Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string) and z(hex, zero padded on the left).Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).The specified number of objects of the specified size are printedaccording to the format. If a negative number is specified, memory isexamined backward from the address.Defaults for format and size letters are those previously used. 这里可以在gdb调试下用 x/s 0x8049fe4 即可打印出我们需要的字符串内容 我的打印出来如下： 12(gdb) x/s 0x8049fe40x8049fe4: \"I am for medical liability at the federal level.\"","link":"/2020/10/29/CSAPP-bomblab-bomb-6/"}],"tags":[{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"hide","slug":"hide","link":"/tags/hide/"},{"name":"毕业寄语","slug":"毕业寄语","link":"/tags/%E6%AF%95%E4%B8%9A%E5%AF%84%E8%AF%AD/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"CSAPP","slug":"CSAPP","link":"/tags/CSAPP/"}],"categories":[{"name":"C语言","slug":"C语言","link":"/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"链表","slug":"C语言/链表","link":"/categories/C%E8%AF%AD%E8%A8%80/%E9%93%BE%E8%A1%A8/"},{"name":"单向链表","slug":"C语言/链表/单向链表","link":"/categories/C%E8%AF%AD%E8%A8%80/%E9%93%BE%E8%A1%A8/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"华东师范大学","slug":"华东师范大学","link":"/categories/%E5%8D%8E%E4%B8%9C%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6/"},{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"CSAPP","slug":"CSAPP","link":"/categories/CSAPP/"},{"name":"bomblab","slug":"CSAPP/bomblab","link":"/categories/CSAPP/bomblab/"}]}