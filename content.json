{"pages":[{"title":"关于我","text":"我是郑逸潇，来自浙江台州，现就读于魔都华东师范大学数据科学与工程学院，热爱计算机、数学、物理。 欢迎大家来看我的博客，也欢迎大家与我交流分享相关知识。 联系方式：QQ：1102100299github账号：zyx-406","link":"/about/index.html"},{"title":"与她","text":"","link":"/abouther/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"AddList.c","text":"1234567891011121314151617181920212223242526272829303132#include \"LinkedList.h\"ListNode *addlist1() //整个数据读取，建立和放入链表都由此函数处理{ int in=0; //in来临时存放读取的数据 ListNode *head=NULL; //头指针 while(in!=-1) { scanf(\"%d\",&amp;in); //读取数据并存放于in if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表 { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL ListNode *tail=head; //定义一个tail寻找此链表的尾端 if(tail) //此处判断tail是否为起始时刻等于NULL的head，若不是则进行下一步寻找 { while(tail-&gt;next) //当tail的next有指向(不是NULL，因为NULL代表0)，则使tail指向下一个节点 { tail=tail-&gt;next; //tail指向下一个节点 } tail-&gt;next=p; //当tail为NULL了让tail指向p，就将p节点从尾端连入链表了 } else { head=p; //此处当head指向NULL时，p为第一个节点 } } } return head; //返回head(传出去的是第一个节点的地址，这个head的地址是在函数调用栈中的，比方在main函数中head=addlist1()，此main中的head与函数中的head的地址不同，但是它们指向的地址是相同的，也就是链表的第一个节点，而链表的节点是由malloc函数实现，当我们没有free它时，它是不会失效的)} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112void addlist2(ListNode *head,int in) //数据在外面读取，此函数负责建立链表并放入，但存在bug，因为此函数的头地址head与传入的地址不是同一个地址，无法在原地方增加链表 所以这是一个错误的函数！！！{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL ListNode *tail=head; //定义一个tail寻找此链表的尾端 if(tail) //此处判断tail是否为起始时刻等于NULL的head，若不是则进行下一步寻找 { while(tail-&gt;next) //当tail的next有指向(不是NULL，因为NULL代表0)，则使tail指向下一个节点 { tail=tail-&gt;next; //tail指向下一个节点 } tail-&gt;next=p; //当tail为NULL了让tail指向p，就将p节点从尾端连入链表了 } else { head=p; //此处当head指向NULL时，p为第一个节点 } }}ListNode *addlist3(ListNode *head,int in) //此函数解决了addlist2的问题，需要返回此函数中head的值，但其实无需传入head的地址，自己定义一个传出也行{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL ListNode *tail=head; //定义一个tail寻找此链表的尾端 if(tail) //此处判断tail是否为起始时刻等于NULL的head，若不是则进行下一步寻找 { while(tail-&gt;next) //当tail的next有指向(不是NULL，因为NULL代表0)，则使tail指向下一个节点 { tail=tail-&gt;next; //tail指向下一个节点 } tail-&gt;next=p; //当tail为NULL了让tail指向p，就将p节点从尾端连入链表了 } else { head=p; //此处当head指向NULL时，p为第一个节点 } } return head; //返回head(传出去的是第一个节点的地址，这个head的地址是在函数调用栈中的，比方在main函数中head=addlist1()，此main中的head与函数中的head的地址不同，但是它们指向的地址是相同的，也就是链表的第一个节点，而链表的节点是由malloc函数实现，当我们没有free它时，它是不会失效的)}void addlist4(ListNode **pHead,int in) //此函数用另一种方法(二级指针)解决了addlist2的问题，且无需返回值{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL ListNode *tail=*pHead; //定义一个tail寻找此链表的尾端 if(tail) //此处判断tail是否为起始时刻等于NULL的head，若不是则进行下一步寻找 { while(tail-&gt;next) //当tail的next有指向(不是NULL，因为NULL代表0)，则使tail指向下一个节点 { tail=tail-&gt;next; //tail指向下一个节点 } tail-&gt;next=p; //当tail为NULL了让tail指向p，就将p节点从尾端连入链表了 } else { *pHead=p; //此处当head指向NULL时，p为第一个节点 } }}//typedef struct _List{ //定义一个结构体包含head和tail可以简化tail的运算// ListNode *head;// ListNode *tail;//}List;void addlist5(List *pList,int in) //加入List结构体定义也可以解决addlist2问题，且加入的List中的tail可以简化tail的运算{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL if(pList-&gt;tail) //此处判断pList-&gt;tail是否为NULL { pList-&gt;tail-&gt;next=p; //使得pList-&gt;tail-&gt;next指向p，就将p节点从尾端连入链表了 pList-&gt;tail=p; //pList-&gt;tail指向p节点 } else { pList-&gt;head=p; //此处当pList-&gt;tail指向NULL时，p为第一个节点 pList-&gt;tail=p; //此处当pList-&gt;tail指向NULL时，p为第一个节点，所以head和tail都是这个节点 } }}void addhead(List *pList,int in) //头部插入新数据{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=pList-&gt;head; //让这个节点的next为head if(pList-&gt;head) //此处判断pList-&gt;tail是否为NULL { pList-&gt;head=p; //使得pList-&gt;head指向p，就将p节点从首端连入链表了 } else { pList-&gt;head=p; //此处当pList-&gt;head指向NULL时，p为第一个节点 pList-&gt;tail=p; //此处当pList-&gt;head指向NULL时，p为第一个节点，所以head和tail都是这个节点 } }}","link":"/2020/07/02/AddList-c/"},{"title":"FreeList.c","text":"1234567891011#include \"LinkedList.h\"void freelist(List *pList) //清除整个链表{ ListNode *p=pList-&gt;head,*q=p; for(;p;p=q) //以往的p=p-&gt;next由p=q代替，q在函数中-&gt;next { q=p-&gt;next; free(p); }}","link":"/2020/07/02/FreeList-c/"},{"title":"DeleteNode.c","text":"第一个代码是按照MOOC代码的改编，所以最后的逻辑处理会有些乱，稍后更新新的代码。 12345678910111213141516171819202122232425262728293031323334#include \"LinkedList.h\" void delete(List *pList,int in) //删除包含in数据的所有节点 { ListNode *p; ListNode *q=NULL; ListNode temp; for(p=pList-&gt;head;p;p=p-&gt;next) //标准遍历 { if(p-&gt;data==in) { if(q) //当q不为NULL时前一个q的next指向p的next即可 { q-&gt;next=p-&gt;next; } else //若q是NULL，也就是说第一个就是我们要删除的节点，让head指向下一个就好 { pList-&gt;head=p-&gt;next; } free(p); //释放malloc来的p if(q) p=q,q=p; //这后面也是重点，因为上面的p已经free掉了，所以p需要重新赋值，才可以删除所有包含in数据的节点，但是由于这个程序这样写逻辑太复杂了，后面我会更新一下简单逻辑的算法。 else { temp.next=pList-&gt;head; p=&amp;temp; } } else { q=p; } } } 第二个代码它来了！ 1234567891011121314151617181920212223242526272829303132#include \"LinkedList.h\"void delete(List *pList,int in){ ListNode *p; ListNode *q=NULL; while(pList-&gt;head) //这里将head部分单独拎出来做文章，避免后面由于考虑head导致逻辑混乱。 { if(pList-&gt;head-&gt;data!=in) break; //如果head不是所要删除的数据直接break开始下个循环。 else //如果是要删除的，删除它并重新赋值head为下一个，free原来的head { q=pList-&gt;head; pList-&gt;head=pList-&gt;head-&gt;next; free(q); } } p=q=pList-&gt;head; //这里我们可以确定head要么没有，为NULL，要么head的数据不是我们需要删除的 while(p) { if(p-&gt;data==in) //如果p的数据是要删除的，进行以下步骤 { q-&gt;next=p-&gt;next; free(p); p=q-&gt;next; //这步就是让整个循环得以进行下去的点，要注意p只需要是q的next就行，因为q的next并没有检查过，且q不变，因而不能和下面的代码合并 } else //如果不是就让q是这个，p往下走就行了 { q=p; p=p-&gt;next; } }}","link":"/2020/07/02/DeleteNode-c/"},{"title":"TraverseList.c","text":"123456789101112131415161718192021222324252627#include \"LinkedList.h\"void print(List *pList) //此函数将链表所有数据输出{ ListNode *p=pList-&gt;head; for(p=pList-&gt;head;p;p=p-&gt;next) //链表遍历常规操作，让p从head开始 当p不为NULL进入循环，之后p指向下一个节点 { printf(\"%d \",p-&gt;data); //输出数据 } printf(\"\\n\");}ListNode *search(List *pList,int in) //此函数搜索链表中有无 in 的数据，并将第一个搜索到的地址返回，若未找到返回NULL{ int flag=0; //用来表示是否找到 ListNode *p=pList-&gt;head; for(;p;p=p-&gt;next) { if(p-&gt;data==in) { flag=1; break; } } if(flag) return p; //找到返回p，未找到返回NULL else return NULL;}","link":"/2020/07/02/TraverseList-c/"},{"title":"InsertNode.c","text":"这部分暂时还没来得及注释，而且实现的可能有点不好 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include \"LinkedList.h\"void insertnode(List *pList,int in) //我这里想实现的是顺序插入，即将给出的数据按从小到大排列{ if(in!=-1) //if in不是结束标志符(这里是-1)，则将in的数据写入链表(此处为防止传入的时候出错，再检查一遍) { ListNode *p=(ListNode*)malloc(sizeof(ListNode)); //动态申请一个单位(节点)的链表内存，并以p为首地址 p-&gt;data=in; //赋予这个节点的数据 in 的值 p-&gt;next=NULL; //让这个节点的next为NULL int flag=1; ListNode *i=pList-&gt;head,*j=NULL; if(pList-&gt;head) { for(i=pList-&gt;head;i;j=i,i=i-&gt;next) //链表遍历常规操作，让p从head开始 当p不为NULL进入循环，之后p指向下一个节点 { if(!j&amp;&amp;i-&gt;data&gt;in) { p-&gt;next=pList-&gt;head; pList-&gt;head=p; flag=0; break; } else if(i-&gt;data&gt;in&amp;&amp;j) { j-&gt;next=p; p-&gt;next=i; flag=0; break; } else; } if(flag) { pList-&gt;tail-&gt;next = p; pList-&gt;tail = p; } } else { pList-&gt;head=p; //此处当pList-&gt;tail指向NULL时，p为第一个节点 pList-&gt;tail=p; //此处当pList-&gt;tail指向NULL时，p为第一个节点，所以head和tail都是这个节点 } }}","link":"/2020/07/02/InsertNode-c/"},{"title":"LinkList.h","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#ifndef LINKEDLIST_LINKEDLIST_H#define LINKEDLIST_LINKEDLIST_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;typedef struct ListNode{ //定义单向链表节点结构体 int data; //链表数据 struct ListNode *next; //指向下一个链表的指针}ListNode; //结构名(可以与上面相同)//*最重要！链表的增加函数，这里以-1为结束标志(之后操作链表尾增加函数都用第五个) 前五个在尾端插入结点，最后一个addhead在头部插入ListNode *addlist1(); //整个数据读取，建立和放入链表都由此函数处理void addlist2(ListNode *head,int in); //数据在外面读取，此函数负责建立链表并放入，但存在bug，因为此函数的头地址head与传入的地址不是同一个地址，无法在原地方增加链表ListNode *addlist3(ListNode *head,int in); //此函数解决了addlist2的问题，需要返回此函数中head的值void addlist4(ListNode **pHead,int in); //此函数用另一种方法(二级指针)解决了addlist2的问题，且无需返回值typedef struct List{ //定义一个结构体包含head和tail可以简化tail的运算 ListNode *head; ListNode *tail;}List;void addlist5(List *pList,int in); //加入List结构体定义也可以解决addlist2问题，且加入的List中的tail可以简化tail的运算void addhead(List *pList,int in); //头部插入新数据//链表节点插入，即在链表中间特定地址插入一个结点void insertnode(List *pList,int in); //我这里想实现的是顺序插入，即将给出的数据按从小到大排列//链表的搜索(遍历)void print(List *pList); //此函数将链表所有数据输出ListNode *search(List *pList,int in); //此函数搜索链表中有无 in 的数据，并将第一个搜索到的地址返回//链表的删除void delete(List *pList,int in); //删除包含in数据的节点//链表的清除 freevoid freelist(List *pList); //清除整个链表#endif //LINKEDLIST_LINKEDLIST_H","link":"/2020/07/02/LinkList-h/"},{"title":"天降大任、苦难出头、花繁九州","text":"“不要成为996 007的社畜，也不要成为高智商高情商无使命的精致利己者” ——华东师范大学校长钱旭红 华东师范大学2020届毕业典礼举行","link":"/2020/06/25/%E5%A4%A9%E9%99%8D%E5%A4%A7%E4%BB%BB%E3%80%81%E8%8B%A6%E9%9A%BE%E5%87%BA%E5%A4%B4%E3%80%81%E8%8A%B1%E7%B9%81%E4%B9%9D%E5%B7%9E/"},{"title":"分类统计字符个数","text":"题目如下： 起初本题的输入令我十分难以理解，没有一个确定的终止命令，后来想到ctrl+Z为终止指令，初步尝试使用getchar函数结果也总是不对。经过研究发现，oj平台的终止方式和我们stdin的不太一样，如果加上换行和ctrl+Z就多了两个字符，我们需要把这两个字符去掉，同时也要注意在开始的时候要是直接输入ctrl+Z换行符的计数是会变成-1的；初步改了一下将这个情况给排除掉就可以过验了。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 100void input(char s[]);void StringCount(char s[]);int main(){ char s[N]={0}; input(s); StringCount(s); return 0;}//读取字符串并放入数组s中void input(char s[]){ int i=0; while((s[i]=getchar())!=EOF) i++;}//处理并输出统计字符的个数void StringCount(char s[]){ int letter=0,kghc=0,digit=0,others=0; while(*s) { if((*s&gt;='a'&amp;&amp;*s&lt;='z')||(*s&gt;='A'&amp;&amp;*s&lt;='Z')) letter++; else if(*s==' '||*s=='\\n') kghc++; else if(*s&gt;='0'&amp;&amp;*s&lt;='9') digit++; else others++; s++; } if(s[1]=='\\0') kghc++; //这一步就是把直接ctrl+Z的情况给排除 printf(\"%d %d %d %d\",letter,--kghc,digit,--others);} 经过与老师同学的交流得知，这类题最好的做法是将字符串逐行进行处理，换行的count++即可 xmx更改的代码如下：123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 100int letter=0,kghc=0,digit=0,others=0;void StringCount(char s[]);int main(){ char s[N]={0}; while(gets(s)!=NULL) { StringCount(s); kghc++; } kghc--; //将最后一个换行给去掉。（ps：但是很奇怪的是用这个逐行读入的居然是不用考虑直接ctrl+Z的情况，尽管我们的终端显示是错误的，但是能过验，这可能与oj平台的测试方式有关） printf(\"%d %d %d %d\",letter,kghc,digit,others); return 0;}void StringCount(char s[]){ while(*s) { if((*s&gt;='a'&amp;&amp;*s&lt;='z')||(*s&gt;='A'&amp;&amp;*s&lt;='Z')) letter++; else if(*s==' '||*s=='\\n') kghc++; else if(*s&gt;='0'&amp;&amp;*s&lt;='9') digit++; else others++; s++; }} 令人更难解的操作来了： 这道题又说明了oj与我们自己的shell的不同 我的过验代码为：12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 100void StringCount(char *s);int main(){ char s[N]={0},t[N]={0}; int i=0; while((s[i]=getchar())!=EOF) i++; s[i]='\\0'; StringCount(s); return 0;}void StringCount(char *s){ int LETTER=0,letter=0,blank=0,digit=0,others=0; for(int i=0;s[i];i++) { if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') LETTER++; else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') letter++; else if(s[i]==' ') blank++; else if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') digit++; else others++; } printf(\"%d %d %d %d %d\",LETTER,letter,blank,digit,others);} 但是在我个人终端的输出是错误的，样例都是错的，输出2 2 1 3 5，不太懂oj和我们的终端的判别到底是怎么不一样的。 至于EOF和NULL链接如下：EOF NULL while(gets(s)!=NULL)指的就是gets()返回过来的是个空指针的话就停下了","link":"/2020/06/28/%E5%88%86%E7%B1%BB%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0/"},{"title":"第一篇博客","text":"这是我的第一篇博客搭建基础博客为了比较完整搭建它，耗费了三天时间，看了许多博主的安装教程，其中关于搭建hexo+github page我觉得最全的是b站 0饭盒君 的教程 链接如下： 如何使用hexo+github搭建个人博客（直播录制） 更改主题在知乎逛了一下看见这款icarus，就下定决心是它了！界面简洁，功能又一样不少。 链接如下： icarus主题 按照说明文档来进行更改（英文一定要好，不然只能靠翻译或者搜别人的更改后文档），其中也踩了几次坑，比如遇到： 123456# Alipay donate button configurations- type: alipay # Alipay qrcode image URL qrcode: ''# Wechat donate button configurations 要想把这一部分全部注释掉，就要把# Alipay donate button configurations下面的那行的 - 一整行删掉或者同样注释掉，这是很容易忽略的一行代码。 头像、图表都还没改，等logo设计出来了再改吧","link":"/2020/06/24/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"单向链表概况","text":"本体系总体参照浙江大学MOOC翁老师的视频，链接如下： C语言程序设计CAPC语言程序设计进阶 单向链表介绍 单向链表（单链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始；链表是使用指针进行构造的列表；又称为结点列表，因为链表是由一个个结点组装起来的；其中每个结点都有指针成员变量指向列表中的下一个结点； 链表是由结点构成，head指针指向第一个成为表头结点，而终止于最后一个指向NULL的指针。 链表相对于数组比较优点： 链表可以有效控制内存使用大小，不会像数组一样出现内存取多了或者少了(数组的大小只能一开始就确定，可变数组也需要不断建立新的再复制，比较麻烦)； 链表在中间插入或删除数据比较方便，只需要进行结点的变化，数组(比较大的数组)新建或删除需要进行大规模移动； 缺点： 单向链表的结点的访问只能顺序访问，当数据规模大了，访问速度比数组慢； 链表占用内存空间较大，其包含数据和指针两部分； 链表的学习和使用 下面是代码实践操作(建议与MOOC共同食用) 单向链表结构体的定义：数据+此结构体类型的指针(这里包括各类函数的定义) 最重要！ 单向链表的建立，包括尾部插入新数据和头部插入新数据 单向链表的插入数据(中间)，在链表中插入新的数据 单向链表的遍历(我这里包括打印链表和搜索特定数据) 单向链表的删除结点 单向链表的清除(使用完后要清除链表)","link":"/2020/07/02/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"},{"title":"CSAPP_bomblab_bomb_6","text":"这是我们这学期计算机系统课（CSAPP）的一个实验，由CMU引进，我所做的bomb是bomb_6。二进制炸弹是一个作为目标代码文件提供给学生们的程序。运行时，它提示用户输入6个不同的字符串。如果其中的任何一个不正确，炸弹就会“爆炸”，打印出一条错误信息。学生们必须通过对程序反汇编（objdump）和查看理解汇编代码来确定应该输入哪6个字符串，从而解除他们各自炸弹的雷管。 前期准备：使用GDB：这是我们班同学写的关于使用GDB的文章GDB简易使用指南 objdump：（可选）大家可以去网上查询objdump的使用方法，这个实验只用到了以下的方法：objdump -d bomb_6或者用objdump -d bomb_6 &gt; bomb_6.d将反汇编代码保存在bomb_6.d的文件中（会在同级文件夹下生成）。 以下就是解题过程main123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687080489db &lt;main&gt;: 80489db: 8d 4c 24 04 lea 0x4(%esp),%ecx 80489df: 83 e4 f0 and $0xfffffff0,%esp 80489e2: ff 71 fc pushl -0x4(%ecx) 80489e5: 55 push %ebp 80489e6: 89 e5 mov %esp,%ebp 80489e8: 53 push %ebx 80489e9: 51 push %ecx 80489ea: 8b 01 mov (%ecx),%eax 80489ec: 8b 59 04 mov 0x4(%ecx),%ebx 80489ef: 83 f8 01 cmp $0x1,%eax 80489f2: 75 0c jne 8048a00 &lt;main+0x25&gt; 80489f4: a1 c0 c3 04 08 mov 0x804c3c0,%eax 80489f9: a3 d0 c3 04 08 mov %eax,0x804c3d0 80489fe: eb 5b jmp 8048a5b &lt;main+0x80&gt; 8048a00: 83 f8 02 cmp $0x2,%eax 8048a03: 75 39 jne 8048a3e &lt;main+0x63&gt; 8048a05: 83 ec 08 sub $0x8,%esp 8048a08: 68 a8 9e 04 08 push $0x8049ea8 8048a0d: ff 73 04 pushl 0x4(%ebx) 8048a10: e8 0b fe ff ff call 8048820 &lt;fopen@plt&gt; 8048a15: a3 d0 c3 04 08 mov %eax,0x804c3d0 8048a1a: 83 c4 10 add $0x10,%esp 8048a1d: 85 c0 test %eax,%eax 8048a1f: 75 3a jne 8048a5b &lt;main+0x80&gt; 8048a21: ff 73 04 pushl 0x4(%ebx) 8048a24: ff 33 pushl (%ebx) 8048a26: 68 aa 9e 04 08 push $0x8049eaa 8048a2b: 6a 01 push $0x1 8048a2d: e8 0e fe ff ff call 8048840 &lt;__printf_chk@plt&gt; 8048a32: c7 04 24 08 00 00 00 movl $0x8,(%esp) 8048a39: e8 a2 fd ff ff call 80487e0 &lt;exit@plt&gt; 8048a3e: 83 ec 04 sub $0x4,%esp 8048a41: ff 33 pushl (%ebx) 8048a43: 68 c7 9e 04 08 push $0x8049ec7 8048a48: 6a 01 push $0x1 8048a4a: e8 f1 fd ff ff call 8048840 &lt;__printf_chk@plt&gt; 8048a4f: c7 04 24 08 00 00 00 movl $0x8,(%esp) 8048a56: e8 85 fd ff ff call 80487e0 &lt;exit@plt&gt; 8048a5b: e8 d1 05 00 00 call 8049031 &lt;initialize_bomb&gt; 8048a60: 83 ec 0c sub $0xc,%esp 8048a63: 68 2c 9f 04 08 push $0x8049f2c 8048a68: e8 53 fd ff ff call 80487c0 &lt;puts@plt&gt; 8048a6d: c7 04 24 68 9f 04 08 movl $0x8049f68,(%esp) 8048a74: e8 47 fd ff ff call 80487c0 &lt;puts@plt&gt; 8048a79: e8 a5 06 00 00 call 8049123 &lt;read_line&gt; 8048a7e: 89 04 24 mov %eax,(%esp) 8048a81: e8 ad 00 00 00 call 8048b33 &lt;phase_1&gt; 8048a86: e8 91 07 00 00 call 804921c &lt;phase_defused&gt; 8048a8b: c7 04 24 94 9f 04 08 movl $0x8049f94,(%esp) 8048a92: e8 29 fd ff ff call 80487c0 &lt;puts@plt&gt; 8048a97: e8 87 06 00 00 call 8049123 &lt;read_line&gt; 8048a9c: 89 04 24 mov %eax,(%esp) 8048a9f: e8 b0 00 00 00 call 8048b54 &lt;phase_2&gt; 8048aa4: e8 73 07 00 00 call 804921c &lt;phase_defused&gt; 8048aa9: c7 04 24 e1 9e 04 08 movl $0x8049ee1,(%esp) 8048ab0: e8 0b fd ff ff call 80487c0 &lt;puts@plt&gt; 8048ab5: e8 69 06 00 00 call 8049123 &lt;read_line&gt; 8048aba: 89 04 24 mov %eax,(%esp) 8048abd: e8 f5 00 00 00 call 8048bb7 &lt;phase_3&gt; 8048ac2: e8 55 07 00 00 call 804921c &lt;phase_defused&gt; 8048ac7: c7 04 24 ff 9e 04 08 movl $0x8049eff,(%esp) 8048ace: e8 ed fc ff ff call 80487c0 &lt;puts@plt&gt; 8048ad3: e8 4b 06 00 00 call 8049123 &lt;read_line&gt; 8048ad8: 89 04 24 mov %eax,(%esp) 8048adb: e8 ed 01 00 00 call 8048ccd &lt;phase_4&gt; 8048ae0: e8 37 07 00 00 call 804921c &lt;phase_defused&gt; 8048ae5: c7 04 24 c0 9f 04 08 movl $0x8049fc0,(%esp) 8048aec: e8 cf fc ff ff call 80487c0 &lt;puts@plt&gt; 8048af1: e8 2d 06 00 00 call 8049123 &lt;read_line&gt; 8048af6: 89 04 24 mov %eax,(%esp) 8048af9: e8 41 02 00 00 call 8048d3f &lt;phase_5&gt; 8048afe: e8 19 07 00 00 call 804921c &lt;phase_defused&gt; 8048b03: c7 04 24 0e 9f 04 08 movl $0x8049f0e,(%esp) 8048b0a: e8 b1 fc ff ff call 80487c0 &lt;puts@plt&gt; 8048b0f: e8 0f 06 00 00 call 8049123 &lt;read_line&gt; 8048b14: 89 04 24 mov %eax,(%esp) 8048b17: e8 6b 02 00 00 call 8048d87 &lt;phase_6&gt; 8048b1c: e8 fb 06 00 00 call 804921c &lt;phase_defused&gt; 8048b21: 83 c4 10 add $0x10,%esp 8048b24: b8 00 00 00 00 mov $0x0,%eax 8048b29: 8d 65 f8 lea -0x8(%ebp),%esp 8048b2c: 59 pop %ecx 8048b2d: 5b pop %ebx 8048b2e: 5d pop %ebp 8048b2f: 8d 61 fc lea -0x4(%ecx),%esp 8048b32: c3 ret 第一关（最基础）123456789101108048b33 &lt;phase_1&gt;: 8048b33: 83 ec 14 sub $0x14,%esp 8048b36: 68 e4 9f 04 08 push $0x8049fe4 8048b3b: ff 74 24 1c pushl 0x1c(%esp) 8048b3f: e8 88 04 00 00 call 8048fcc &lt;strings_not_equal&gt; 8048b44: 83 c4 10 add $0x10,%esp 8048b47: 85 c0 test %eax,%eax 8048b49: 74 05 je 8048b50 &lt;phase_1+0x1d&gt; 8048b4b: e8 73 05 00 00 call 80490c3 &lt;explode_bomb&gt; 8048b50: 83 c4 0c add $0xc,%esp 8048b53: c3 ret 这是最简单的一题，关键在于strings_not_equal函数和它的前两行 1238048b36: 68 e4 9f 04 08 push $0x8049fe4 //将这个地址里的东西压入栈8048b3b: ff 74 24 1c pushl 0x1c(%esp) //将输入的字符串压入栈8048b3f: e8 88 04 00 00 call 8048fcc &lt;strings_not_equal&gt; //这个函数比较两个字符串是否相同（从函数名就可以看出） 因此我们需要把0x8049fe4地址里的东西找出来 这里用到了x打印出这个内存地址里的内容，以下是x的使用方法 12345678910111213(gdb) help xExamine memory: x/FMT ADDRESS.ADDRESS is an expression for the memory address to examine.FMT is a repeat count followed by a format letter and a size letter.Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string) and z(hex, zero padded on the left).Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).The specified number of objects of the specified size are printedaccording to the format. If a negative number is specified, memory isexamined backward from the address.Defaults for format and size letters are those previously used. 这里可以在gdb调试下用 x/s 0x8049fe4 即可打印出我们需要的字符串内容 我的打印出来如下： 12(gdb) x/s 0x8049fe40x8049fe4: \"I am for medical liability at the federal level.\" 因此我们输入 I am for medical liability at the federal level. 就可以成功通过第一关。 第二关（考察循环）12345678910111213141516171819202122232425262728293031323308048b54 &lt;phase_2&gt;: 8048b54: 56 push %esi 8048b55: 53 push %ebx 8048b56: 83 ec 2c sub $0x2c,%esp 8048b59: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048b5f: 89 44 24 24 mov %eax,0x24(%esp) 8048b63: 31 c0 xor %eax,%eax 8048b65: 8d 44 24 0c lea 0xc(%esp),%eax 8048b69: 50 push %eax 8048b6a: ff 74 24 3c pushl 0x3c(%esp) 8048b6e: e8 75 05 00 00 call 80490e8 &lt;read_six_numbers&gt; 8048b73: 83 c4 10 add $0x10,%esp 8048b76: 83 7c 24 04 01 cmpl $0x1,0x4(%esp) 8048b7b: 74 05 je 8048b82 &lt;phase_2+0x2e&gt; 8048b7d: e8 41 05 00 00 call 80490c3 &lt;explode_bomb&gt; 8048b82: 8d 5c 24 04 lea 0x4(%esp),%ebx 8048b86: 8d 74 24 18 lea 0x18(%esp),%esi 8048b8a: 8b 03 mov (%ebx),%eax 8048b8c: 01 c0 add %eax,%eax 8048b8e: 39 43 04 cmp %eax,0x4(%ebx) 8048b91: 74 05 je 8048b98 &lt;phase_2+0x44&gt; 8048b93: e8 2b 05 00 00 call 80490c3 &lt;explode_bomb&gt; 8048b98: 83 c3 04 add $0x4,%ebx 8048b9b: 39 f3 cmp %esi,%ebx 8048b9d: 75 eb jne 8048b8a &lt;phase_2+0x36&gt; 8048b9f: 8b 44 24 1c mov 0x1c(%esp),%eax 8048ba3: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048baa: 74 05 je 8048bb1 &lt;phase_2+0x5d&gt; 8048bac: e8 df fb ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 8048bb1: 83 c4 24 add $0x24,%esp 8048bb4: 5b pop %ebx 8048bb5: 5e pop %esi 8048bb6: c3 ret 从8048b6e: e8 75 05 00 00 call 80490e8 &lt;read_six_numbers&gt;这一行可以看出，这里需要读取六个数字（就是把输入的字符串中的六个数字提取出来） 核心的汇编代码就是以下的部分： 123456789101112131415161718198048b65: 8d 44 24 0c lea 0xc(%esp),%eax //将 esp+0xc 放入eax中8048b69: 50 push %eax //将eax的值压入栈中，从这里我们可以猜测地址 esp+0xc 用来放第一个数，esp+0x10 用来放第二个数，以此类推8048b73: 83 c4 10 add $0x10,%esp //栈顶指针向上移动，所以下面的 esp+0x4 和上面的 esp+0xc 是同一个地址，用来存放数8048b76: 83 7c 24 04 01 cmpl $0x1,0x4(%esp) //比较 *(esp+0x4) 和 1 的值，从下一行不等就爆炸可以看出这里 *(esp+0x4) 的值必须是18048b7b: 74 05 je 8048b82 &lt;phase_2+0x2e&gt; //jump if equal8048b7d: e8 41 05 00 00 call 80490c3 &lt;explode_bomb&gt; //8048b82: 8d 5c 24 04 lea 0x4(%esp),%ebx //将输入的第一个值的地址放入ebx中8048b86: 8d 74 24 18 lea 0x18(%esp),%esi //将第六个数的地址放入esi中//↓以下是一个循环结构8048b8a: 8b 03 mov (%ebx),%eax //将第一个数放入eax中8048b8c: 01 c0 add %eax,%eax //eax = eax + eax，就是把eax变成两倍8048b8e: 39 43 04 cmp %eax,0x4(%ebx) //比较第二个数和eax8048b91: 74 05 je 8048b98 &lt;phase_2+0x44&gt; //如果不同就爆炸8048b93: e8 2b 05 00 00 call 80490c3 &lt;explode_bomb&gt; //8048b98: 83 c3 04 add $0x4,%ebx //将ebx的地址+4，就是来到了第二个数的地址8048b9b: 39 f3 cmp %esi,%ebx //比较ebx和esi，就是看地址是不是来到了第六个数的地址，如果已经到第六个数了，那么这两个地址就相等了，循环退出8048b9d: 75 eb jne 8048b8a &lt;phase_2+0x36&gt; //不相同就循环以上部分//↑ 所以由此可得，第一个输入的数必须是1，第二个数是第一个数的两倍，第三个数是第二个数的两倍，以此类推…… 因此答案为：1 2 4 8 16 32 输入答案，第二关就可以成功通过了 第三关（考察switch-case）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555608048bb7 &lt;phase_3&gt;: 8048bb7: 83 ec 1c sub $0x1c,%esp 8048bba: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048bc0: 89 44 24 0c mov %eax,0xc(%esp) 8048bc4: 31 c0 xor %eax,%eax 8048bc6: 8d 44 24 08 lea 0x8(%esp),%eax 8048bca: 50 push %eax 8048bcb: 8d 44 24 08 lea 0x8(%esp),%eax 8048bcf: 50 push %eax 8048bd0: 68 af a1 04 08 push $0x804a1af 8048bd5: ff 74 24 2c pushl 0x2c(%esp) 8048bd9: e8 32 fc ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 8048bde: 83 c4 10 add $0x10,%esp 8048be1: 83 f8 01 cmp $0x1,%eax 8048be4: 7f 05 jg 8048beb &lt;phase_3+0x34&gt; 8048be6: e8 d8 04 00 00 call 80490c3 &lt;explode_bomb&gt; 8048beb: 83 7c 24 04 07 cmpl $0x7,0x4(%esp) 8048bf0: 77 66 ja 8048c58 &lt;phase_3+0xa1&gt; 8048bf2: 8b 44 24 04 mov 0x4(%esp),%eax 8048bf6: ff 24 85 40 a0 04 08 jmp *0x804a040(,%eax,4) 8048bfd: b8 a2 00 00 00 mov $0xa2,%eax 8048c02: eb 05 jmp 8048c09 &lt;phase_3+0x52&gt; 8048c04: b8 00 00 00 00 mov $0x0,%eax 8048c09: 2d 6f 02 00 00 sub $0x26f,%eax 8048c0e: eb 05 jmp 8048c15 &lt;phase_3+0x5e&gt; 8048c10: b8 00 00 00 00 mov $0x0,%eax 8048c15: 05 32 02 00 00 add $0x232,%eax 8048c1a: eb 05 jmp 8048c21 &lt;phase_3+0x6a&gt; 8048c1c: b8 00 00 00 00 mov $0x0,%eax 8048c21: 2d e8 03 00 00 sub $0x3e8,%eax 8048c26: eb 05 jmp 8048c2d &lt;phase_3+0x76&gt; 8048c28: b8 00 00 00 00 mov $0x0,%eax 8048c2d: 05 e8 03 00 00 add $0x3e8,%eax 8048c32: eb 05 jmp 8048c39 &lt;phase_3+0x82&gt; 8048c34: b8 00 00 00 00 mov $0x0,%eax 8048c39: 2d e8 03 00 00 sub $0x3e8,%eax 8048c3e: eb 05 jmp 8048c45 &lt;phase_3+0x8e&gt; 8048c40: b8 00 00 00 00 mov $0x0,%eax 8048c45: 05 e8 03 00 00 add $0x3e8,%eax 8048c4a: eb 05 jmp 8048c51 &lt;phase_3+0x9a&gt; 8048c4c: b8 00 00 00 00 mov $0x0,%eax 8048c51: 2d e8 03 00 00 sub $0x3e8,%eax 8048c56: eb 0a jmp 8048c62 &lt;phase_3+0xab&gt; 8048c58: e8 66 04 00 00 call 80490c3 &lt;explode_bomb&gt; 8048c5d: b8 00 00 00 00 mov $0x0,%eax 8048c62: 83 7c 24 04 05 cmpl $0x5,0x4(%esp) 8048c67: 7f 06 jg 8048c6f &lt;phase_3+0xb8&gt; 8048c69: 3b 44 24 08 cmp 0x8(%esp),%eax 8048c6d: 74 05 je 8048c74 &lt;phase_3+0xbd&gt; 8048c6f: e8 4f 04 00 00 call 80490c3 &lt;explode_bomb&gt; 8048c74: 8b 44 24 0c mov 0xc(%esp),%eax 8048c78: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048c7f: 74 05 je 8048c86 &lt;phase_3+0xcf&gt; 8048c81: e8 0a fb ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 8048c86: 83 c4 1c add $0x1c,%esp 8048c89: c3 ret 第三题的代码长度就有点长了，但是看代码可以看出有很多相似的代码，这个和跳转表的结构非常像，所以可以判断本题考察的是switch-case的汇编实现 我将这题分成了三个部分 以下是第一部分 12345678910118048bc6: 8d 44 24 08 lea 0x8(%esp),%eax //压入第二个输入数的地址8048bca: 50 push %eax8048bcb: 8d 44 24 08 lea 0x8(%esp),%eax //压入第一个输入数的地址8048bcf: 50 push %eax8048bd0: 68 af a1 04 08 push $0x804a1af //这里需要查看压入栈的地址上的值是什么，由scanf需要的参数可以得知，这里应该压入栈的是一个字符串8048bd5: ff 74 24 2c pushl 0x2c(%esp)8048bd9: e8 32 fc ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; //scanf，语法是scanf(\"%d\")等等8048bde: 83 c4 10 add $0x10,%esp8048be1: 83 f8 01 cmp $0x1,%eax //比较eax和1（这里eax的值是输入参数的个数，是scanf的返回值）8048be4: 7f 05 jg 8048beb &lt;phase_3+0x34&gt; //输入的数个数要大于1不然就爆炸8048be6: e8 d8 04 00 00 call 80490c3 &lt;explode_bomb&gt; 我们来看看 0x804a1af 地址上的值是什么，这里猜测它是字符串，因此也用 x/sx/s 0x804a1af可得 12(gdb) x/s 0x804a1af0x804a1af: \"%d %d\" 联想scanf的语法，可以看出需要输入两个整数，中间以空格隔开 然后是第二部分 12345678910111213141516171819202122232425268048beb: 83 7c 24 04 07 cmpl $0x7,0x4(%esp) //比较输入的第一个数和78048bf0: 77 66 ja 8048c58 &lt;phase_3+0xa1&gt; //如果第一个数大于7或者小于0就跳到爆炸那一行命令。这里运用了一个技巧，ja比较的是无符号整数，如果前一个语句cmp后面的数大于前面的数，就跳转，由于有符号数里负数的第一个位肯定是1，转换成无符号数必然会比有符号数的最大的数大，所以如果值是负数就会跳转到爆炸命令，原理是条件码的设定也是有分有无符号的，这个技巧在后面都会有用到。8048bf2: 8b 44 24 04 mov 0x4(%esp),%eax //将输入的第一个值放入eax中8048bf6: ff 24 85 40 a0 04 08 jmp *0x804a040(,%eax,4) //这里可以看出是一个跳转表*0x804a040，可以用x/a 0x804a040打印出这个地址上的值8048bfd: b8 a2 00 00 00 mov $0xa2,%eax //都是和eax进行的简单运算↓8048c02: eb 05 jmp 8048c09 &lt;phase_3+0x52&gt;8048c04: b8 00 00 00 00 mov $0x0,%eax8048c09: 2d 6f 02 00 00 sub $0x26f,%eax8048c0e: eb 05 jmp 8048c15 &lt;phase_3+0x5e&gt;8048c10: b8 00 00 00 00 mov $0x0,%eax8048c15: 05 32 02 00 00 add $0x232,%eax8048c1a: eb 05 jmp 8048c21 &lt;phase_3+0x6a&gt;8048c1c: b8 00 00 00 00 mov $0x0,%eax8048c21: 2d e8 03 00 00 sub $0x3e8,%eax8048c26: eb 05 jmp 8048c2d &lt;phase_3+0x76&gt;8048c28: b8 00 00 00 00 mov $0x0,%eax8048c2d: 05 e8 03 00 00 add $0x3e8,%eax8048c32: eb 05 jmp 8048c39 &lt;phase_3+0x82&gt;8048c34: b8 00 00 00 00 mov $0x0,%eax8048c39: 2d e8 03 00 00 sub $0x3e8,%eax8048c3e: eb 05 jmp 8048c45 &lt;phase_3+0x8e&gt;8048c40: b8 00 00 00 00 mov $0x0,%eax8048c45: 05 e8 03 00 00 add $0x3e8,%eax8048c4a: eb 05 jmp 8048c51 &lt;phase_3+0x9a&gt;8048c4c: b8 00 00 00 00 mov $0x0,%eax8048c51: 2d e8 03 00 00 sub $0x3e8,%eax //都是和eax进行的简单运算↑ 这里关键就是跳转表那一行8048bf6: ff 24 85 40 a0 04 08 jmp *0x804a040(,%eax,4)利用x/a 0x804a040打印出结果为： 12(gdb) x/a 0x804a0400x804a040: 0x8048bfd &lt;phase_3+70&gt; 就是8048bfd: b8 a2 00 00 00 mov $0xa2,%eax这一行然后进行 0x8048bfd+4*eax 运算得出需要跳转到的行数，从后面的代码可以看出每个case都没有break由于输入的第一个值不同，eax的值也不同，因此计算出来的结果也不同，可以猜测本题不止一个答案，由第二部分第一个命令进一步推断输入的第一个值应该是0-7，一共八组答案（后面会进一步推断这个判断是错误的） 最后是第三部分： 1234567898048c56: eb 0a jmp 8048c62 &lt;phase_3+0xab&gt; //从 8048c62 行开始下一步8048c58: e8 66 04 00 00 call 80490c3 &lt;explode_bomb&gt;8048c5d: b8 00 00 00 00 mov $0x0,%eax8048c62: 83 7c 24 04 05 cmpl $0x5,0x4(%esp) //比较第一个数和5的大小8048c67: 7f 06 jg 8048c6f &lt;phase_3+0xb8&gt; //如果比5大就跳转到爆炸命令8048c69: 3b 44 24 08 cmp 0x8(%esp),%eax //比较第二个数和第二部分计算出来的eax8048c6d: 74 05 je 8048c74 &lt;phase_3+0xbd&gt; //如果不相等就跳转到爆炸命令8048c6f: e8 4f 04 00 00 call 80490c3 &lt;explode_bomb&gt;8048c74: 8b 44 24 0c mov 0xc(%esp),%eax 第三部分命令就很清晰明了了，两方面：1、第一个数不能大于5（所以本题第一个数为0-5，六种答案）2、第二个数要和第一个数所代表的case在第二部分计算出来的结果相匹配 我选择的第一个数就是0，计算出来第二个数结果为-899 因此输入0 -899，第三题成功破解！ 第四关（考察调用函数和出入栈）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646508048c8a &lt;func4&gt;: 8048c8a: 57 push %edi 8048c8b: 56 push %esi 8048c8c: 53 push %ebx 8048c8d: 8b 5c 24 10 mov 0x10(%esp),%ebx 8048c91: 8b 7c 24 14 mov 0x14(%esp),%edi 8048c95: 85 db test %ebx,%ebx 8048c97: 7e 2b jle 8048cc4 &lt;func4+0x3a&gt; 8048c99: 89 f8 mov %edi,%eax 8048c9b: 83 fb 01 cmp $0x1,%ebx 8048c9e: 74 29 je 8048cc9 &lt;func4+0x3f&gt; 8048ca0: 83 ec 08 sub $0x8,%esp 8048ca3: 57 push %edi 8048ca4: 8d 43 ff lea -0x1(%ebx),%eax 8048ca7: 50 push %eax 8048ca8: e8 dd ff ff ff call 8048c8a &lt;func4&gt; 8048cad: 83 c4 08 add $0x8,%esp 8048cb0: 8d 34 07 lea (%edi,%eax,1),%esi 8048cb3: 57 push %edi 8048cb4: 83 eb 02 sub $0x2,%ebx 8048cb7: 53 push %ebx 8048cb8: e8 cd ff ff ff call 8048c8a &lt;func4&gt; 8048cbd: 83 c4 10 add $0x10,%esp 8048cc0: 01 f0 add %esi,%eax 8048cc2: eb 05 jmp 8048cc9 &lt;func4+0x3f&gt; 8048cc4: b8 00 00 00 00 mov $0x0,%eax 8048cc9: 5b pop %ebx 8048cca: 5e pop %esi 8048ccb: 5f pop %edi 8048ccc: c3 ret 08048ccd &lt;phase_4&gt;: 8048ccd: 83 ec 1c sub $0x1c,%esp 8048cd0: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048cd6: 89 44 24 0c mov %eax,0xc(%esp) 8048cda: 31 c0 xor %eax,%eax 8048cdc: 8d 44 24 04 lea 0x4(%esp),%eax 8048ce0: 50 push %eax 8048ce1: 8d 44 24 0c lea 0xc(%esp),%eax 8048ce5: 50 push %eax 8048ce6: 68 af a1 04 08 push $0x804a1af 8048ceb: ff 74 24 2c pushl 0x2c(%esp) 8048cef: e8 1c fb ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 8048cf4: 83 c4 10 add $0x10,%esp 8048cf7: 83 f8 02 cmp $0x2,%eax 8048cfa: 75 0c jne 8048d08 &lt;phase_4+0x3b&gt; //%eax=2 8048cfc: 8b 44 24 04 mov 0x4(%esp),%eax 8048d00: 83 e8 02 sub $0x2,%eax 8048d03: 83 f8 02 cmp $0x2,%eax //第二个数在2-4之间 8048d06: 76 05 jbe 8048d0d &lt;phase_4+0x40&gt; 8048d08: e8 b6 03 00 00 call 80490c3 &lt;explode_bomb&gt; 8048d0d: 83 ec 08 sub $0x8,%esp 8048d10: ff 74 24 0c pushl 0xc(%esp) //传入的第二个数为func的第一个参数 8048d14: 6a 08 push $0x8 //第二个参数是8 8048d16: e8 6f ff ff ff call 8048c8a &lt;func4&gt; 8048d1b: 83 c4 10 add $0x10,%esp 8048d1e: 3b 44 24 08 cmp 0x8(%esp),%eax //比较第一个数和fucn出来的数，必须要相等 8048d22: 74 05 je 8048d29 &lt;phase_4+0x5c&gt; 8048d24: e8 9a 03 00 00 call 80490c3 &lt;explode_bomb&gt; 8048d29: 8b 44 24 0c mov 0xc(%esp),%eax 8048d2d: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048d34: 74 05 je 8048d3b &lt;phase_4+0x6e&gt; 8048d36: e8 55 fa ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 8048d3b: 83 c4 1c add $0x1c,%esp 8048d3e: c3 ret 第五关1234567891011121314151617181920212223242508048d3f &lt;phase_5&gt;: 8048d3f: 53 push %ebx 8048d40: 83 ec 14 sub $0x14,%esp 8048d43: 8b 5c 24 1c mov 0x1c(%esp),%ebx 8048d47: 53 push %ebx 8048d48: e8 60 02 00 00 call 8048fad &lt;string_length&gt; 8048d4d: 83 c4 10 add $0x10,%esp 8048d50: 83 f8 06 cmp $0x6,%eax 8048d53: 74 05 je 8048d5a &lt;phase_5+0x1b&gt; 8048d55: e8 69 03 00 00 call 80490c3 &lt;explode_bomb&gt; 8048d5a: 89 d8 mov %ebx,%eax 8048d5c: 83 c3 06 add $0x6,%ebx 8048d5f: b9 00 00 00 00 mov $0x0,%ecx 8048d64: 0f b6 10 movzbl (%eax),%edx 8048d67: 83 e2 0f and $0xf,%edx 8048d6a: 03 0c 95 60 a0 04 08 add 0x804a060(,%edx,4),%ecx 8048d71: 83 c0 01 add $0x1,%eax 8048d74: 39 d8 cmp %ebx,%eax 8048d76: 75 ec jne 8048d64 &lt;phase_5+0x25&gt; 8048d78: 83 f9 2a cmp $0x2a,%ecx 8048d7b: 74 05 je 8048d82 &lt;phase_5+0x43&gt; 8048d7d: e8 41 03 00 00 call 80490c3 &lt;explode_bomb&gt; 8048d82: 83 c4 08 add $0x8,%esp 8048d85: 5b pop %ebx 8048d86: c3 ret 第六关12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838408048d87 &lt;phase_6&gt;: 8048d87: 56 push %esi 8048d88: 53 push %ebx 8048d89: 83 ec 4c sub $0x4c,%esp 8048d8c: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048d92: 89 44 24 44 mov %eax,0x44(%esp) 8048d96: 31 c0 xor %eax,%eax 8048d98: 8d 44 24 14 lea 0x14(%esp),%eax 8048d9c: 50 push %eax 8048d9d: ff 74 24 5c pushl 0x5c(%esp) 8048da1: e8 42 03 00 00 call 80490e8 &lt;read_six_numbers&gt; 8048da6: 83 c4 10 add $0x10,%esp 8048da9: be 00 00 00 00 mov $0x0,%esi 8048dae: 8b 44 b4 0c mov 0xc(%esp,%esi,4),%eax 8048db2: 83 e8 01 sub $0x1,%eax 8048db5: 83 f8 05 cmp $0x5,%eax 8048db8: 76 05 jbe 8048dbf &lt;phase_6+0x38&gt; //输入的六个数范围是1-6 8048dba: e8 04 03 00 00 call 80490c3 &lt;explode_bomb&gt; 8048dbf: 83 c6 01 add $0x1,%esi //esi++ 8048dc2: 83 fe 06 cmp $0x6,%esi //第七个数 8048dc5: 74 1b je 8048de2 &lt;phase_6+0x5b&gt; 8048dc7: 89 f3 mov %esi,%ebx //下面代码确保每个数都不同 8048dc9: 8b 44 9c 0c mov 0xc(%esp,%ebx,4),%eax 8048dcd: 39 44 b4 08 cmp %eax,0x8(%esp,%esi,4) 8048dd1: 75 05 jne 8048dd8 &lt;phase_6+0x51&gt; 8048dd3: e8 eb 02 00 00 call 80490c3 &lt;explode_bomb&gt; 8048dd8: 83 c3 01 add $0x1,%ebx 8048ddb: 83 fb 05 cmp $0x5,%ebx 8048dde: 7e e9 jle 8048dc9 &lt;phase_6+0x42&gt; 8048de0: eb cc jmp 8048dae &lt;phase_6+0x27&gt; 8048de2: 8d 44 24 0c lea 0xc(%esp),%eax //eax为第一个数的地址 8048de6: 8d 5c 24 24 lea 0x24(%esp),%ebx //ebx为第七个数的地址 8048dea: b9 07 00 00 00 mov $0x7,%ecx //ecx = 7 8048def: 89 ca mov %ecx,%edx //edx = ecx = 7 ↓ 8048df1: 2b 10 sub (%eax),%edx //edx = edx - 第eax个数 8048df3: 89 10 mov %edx,(%eax) //edx保存到第eax个数所在的地址 8048df5: 83 c0 04 add $0x4,%eax //eax改成第eax + 1个数的地址 8048df8: 39 c3 cmp %eax,%ebx //eax要不等于第七个数地址才循环 8048dfa: 75 f3 jne 8048def &lt;phase_6+0x68&gt; //循环以上步骤 ↑ 8048dfc: bb 00 00 00 00 mov $0x0,%ebx //ebx = 0 8048e01: eb 16 jmp 8048e19 &lt;phase_6+0x92&gt; // 8048e03: 8b 52 08 mov 0x8(%edx),%edx //edx = *(edx + 8) 8048e06: 83 c0 01 add $0x1,%eax //eax += 1 8048e09: 39 c8 cmp %ecx,%eax //ecx vs eax 8048e0b: 75 f6 jne 8048e03 &lt;phase_6+0x7c&gt; //if 不相等 循环以上步骤 8048e0d: 89 54 b4 24 mov %edx,0x24(%esp,%esi,4) //第esi + 6个数 = edx 8048e11: 83 c3 01 add $0x1,%ebx //ebx++ 8048e14: 83 fb 06 cmp $0x6,%ebx //ebx vs 6 8048e17: 74 17 je 8048e30 &lt;phase_6+0xa9&gt; // 8048e19: 89 de mov %ebx,%esi //esi = ebx = 0 8048e1b: 8b 4c 9c 0c mov 0xc(%esp,%ebx,4),%ecx //ecx = 第ebx+1个数 8048e1f: b8 01 00 00 00 mov $0x1,%eax //eax = 1 8048e24: ba 3c c1 04 08 mov $0x804c13c,%edx //edx = 0x804c13c 8048e29: 83 f9 01 cmp $0x1,%ecx //ecx 与 1 比较 8048e2c: 7f d5 jg 8048e03 &lt;phase_6+0x7c&gt; //if ecx &gt; 1 jump 8048e2e: eb dd jmp 8048e0d &lt;phase_6+0x86&gt; // 8048e30: 8b 5c 24 24 mov 0x24(%esp),%ebx //ebx = 第七个数的值 8048e34: 8d 44 24 24 lea 0x24(%esp),%eax //eax = 第七个数的地址 8048e38: 8d 74 24 38 lea 0x38(%esp),%esi //esi = 第十二个数的地址 8048e3c: 89 d9 mov %ebx,%ecx //ecx = ebx 8048e3e: 8b 50 04 mov 0x4(%eax),%edx //edx = 第eax + 1个数的值 ↓ 8048e41: 89 51 08 mov %edx,0x8(%ecx) //ecx的地址指向第八个数的值 8048e44: 83 c0 04 add $0x4,%eax //eax的地址加四 8048e47: 89 d1 mov %edx,%ecx //ecx = edx 8048e49: 39 c6 cmp %eax,%esi // 8048e4b: 75 f1 jne 8048e3e &lt;phase_6+0xb7&gt; //循环以上步骤 ↑ 8048e4d: c7 42 08 00 00 00 00 movl $0x0,0x8(%edx) //链表最后一个的结点指针指向0 8048e54: be 05 00 00 00 mov $0x5,%esi //esi = 5 8048e59: 8b 43 08 mov 0x8(%ebx),%eax //eax = 头指针 ↓ 8048e5c: 8b 00 mov (%eax),%eax //eax = 头指针的值 8048e5e: 39 03 cmp %eax,(%ebx) //第一个数 vs 第七个数 8048e60: 7d 05 jge 8048e67 &lt;phase_6+0xe0&gt; //ebx &gt; 结点值 8048e62: e8 5c 02 00 00 call 80490c3 &lt;explode_bomb&gt; 8048e67: 8b 5b 08 mov 0x8(%ebx),%ebx //ebx到下一个节点 8048e6a: 83 ee 01 sub $0x1,%esi //esi-- 8048e6d: 75 ea jne 8048e59 &lt;phase_6+0xd2&gt; //循环以上步骤 ↑ 8048e6f: 8b 44 24 3c mov 0x3c(%esp),%eax 8048e73: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048e7a: 74 05 je 8048e81 &lt;phase_6+0xfa&gt; 8048e7c: e8 0f f9 ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 8048e81: 83 c4 44 add $0x44,%esp 8048e84: 5b pop %ebx 8048e85: 5e pop %esi 8048e86: c3 ret 隐藏关卡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616208048e87 &lt;fun7&gt;: 8048e87: 53 push %ebx 8048e88: 83 ec 08 sub $0x8,%esp 8048e8b: 8b 54 24 10 mov 0x10(%esp),%edx 8048e8f: 8b 4c 24 14 mov 0x14(%esp),%ecx 8048e93: 85 d2 test %edx,%edx 8048e95: 74 37 je 8048ece &lt;fun7+0x47&gt; 8048e97: 8b 1a mov (%edx),%ebx 8048e99: 39 cb cmp %ecx,%ebx 8048e9b: 7e 13 jle 8048eb0 &lt;fun7+0x29&gt; 8048e9d: 83 ec 08 sub $0x8,%esp 8048ea0: 51 push %ecx 8048ea1: ff 72 04 pushl 0x4(%edx) 8048ea4: e8 de ff ff ff call 8048e87 &lt;fun7&gt; 8048ea9: 83 c4 10 add $0x10,%esp 8048eac: 01 c0 add %eax,%eax 8048eae: eb 23 jmp 8048ed3 &lt;fun7+0x4c&gt; 8048eb0: b8 00 00 00 00 mov $0x0,%eax 8048eb5: 39 cb cmp %ecx,%ebx 8048eb7: 74 1a je 8048ed3 &lt;fun7+0x4c&gt; 8048eb9: 83 ec 08 sub $0x8,%esp 8048ebc: 51 push %ecx 8048ebd: ff 72 08 pushl 0x8(%edx) 8048ec0: e8 c2 ff ff ff call 8048e87 &lt;fun7&gt; 8048ec5: 83 c4 10 add $0x10,%esp 8048ec8: 8d 44 00 01 lea 0x1(%eax,%eax,1),%eax 8048ecc: eb 05 jmp 8048ed3 &lt;fun7+0x4c&gt; 8048ece: b8 ff ff ff ff mov $0xffffffff,%eax 8048ed3: 83 c4 08 add $0x8,%esp 8048ed6: 5b pop %ebx 8048ed7: c3 ret 08048ed8 &lt;secret_phase&gt;: 8048ed8: 53 push %ebx 8048ed9: 83 ec 08 sub $0x8,%esp 8048edc: e8 42 02 00 00 call 8049123 &lt;read_line&gt; 8048ee1: 83 ec 04 sub $0x4,%esp 8048ee4: 6a 0a push $0xa 8048ee6: 6a 00 push $0x0 8048ee8: 50 push %eax 8048ee9: e8 92 f9 ff ff call 8048880 &lt;strtol@plt&gt; 8048eee: 89 c3 mov %eax,%ebx 8048ef0: 8d 40 ff lea -0x1(%eax),%eax 8048ef3: 83 c4 10 add $0x10,%esp 8048ef6: 3d e8 03 00 00 cmp $0x3e8,%eax 8048efb: 76 05 jbe 8048f02 &lt;secret_phase+0x2a&gt; 8048efd: e8 c1 01 00 00 call 80490c3 &lt;explode_bomb&gt; 8048f02: 83 ec 08 sub $0x8,%esp 8048f05: 53 push %ebx 8048f06: 68 88 c0 04 08 push $0x804c088 8048f0b: e8 77 ff ff ff call 8048e87 &lt;fun7&gt; 8048f10: 83 c4 10 add $0x10,%esp 8048f13: 83 f8 04 cmp $0x4,%eax 8048f16: 74 05 je 8048f1d &lt;secret_phase+0x45&gt; 8048f18: e8 a6 01 00 00 call 80490c3 &lt;explode_bomb&gt; 8048f1d: 83 ec 0c sub $0xc,%esp 8048f20: 68 18 a0 04 08 push $0x804a018 8048f25: e8 96 f8 ff ff call 80487c0 &lt;puts@plt&gt; 8048f2a: e8 ed 02 00 00 call 804921c &lt;phase_defused&gt; 8048f2f: 83 c4 18 add $0x18,%esp 8048f32: 5b pop %ebx 8048f33: c3 ret 我的通关方案123456789101112131415161718192021(gdb) rStarting program: /home/csapp08/lab2/bomb_6 Welcome to my fiendish little bomb. You have 6 phases withwhich to blow yourself up. Have a nice day!I am for medical liability at the federal level.Phase 1 defused. How about the next one?1 2 4 8 16 32That's number 2. Keep going!0 -899Halfway there!162 3 DrEvilSo you got that one. Try this one. !!\"$ //两个空格两个感叹号一个双引号一个美刀符号Good work! On to the next...5 2 1 3 4 6Curses, you've found the secret phase!But finding it and solving it are quite different...7Wow! You've defused the secret stage!Congratulations! You've defused the bomb![Inferior 1 (process 58355) exited normally]","link":"/2020/10/29/CSAPP-bomblab-bomb-6/"}],"tags":[{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"hide","slug":"hide","link":"/tags/hide/"},{"name":"毕业寄语","slug":"毕业寄语","link":"/tags/%E6%AF%95%E4%B8%9A%E5%AF%84%E8%AF%AD/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"CSAPP","slug":"CSAPP","link":"/tags/CSAPP/"}],"categories":[{"name":"C语言","slug":"C语言","link":"/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"链表","slug":"C语言/链表","link":"/categories/C%E8%AF%AD%E8%A8%80/%E9%93%BE%E8%A1%A8/"},{"name":"单向链表","slug":"C语言/链表/单向链表","link":"/categories/C%E8%AF%AD%E8%A8%80/%E9%93%BE%E8%A1%A8/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"华东师范大学","slug":"华东师范大学","link":"/categories/%E5%8D%8E%E4%B8%9C%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6/"},{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"CSAPP","slug":"CSAPP","link":"/categories/CSAPP/"},{"name":"bomblab","slug":"CSAPP/bomblab","link":"/categories/CSAPP/bomblab/"}]}